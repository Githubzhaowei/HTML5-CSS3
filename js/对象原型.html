<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>对象原型</title>
        <style>
            section {
                display: flex;
            }
            div {
                width: 50%;
            }
        </style>
    </head>
    <body>
        <section>
            <div>
                <h3>非原型链继承</h3>
                <pre>
function Cat(name) {
    this.name = name;
    this.say = function () {
        console.log(this.name + "是猫");
    };
}

var tom = new Cat("TOM");
var jarry = new Cat("JARRY");

tom.say();
jarry.say();

console.log(tom);
console.log(jarry);
console.log(isChild(tom, Cat));

//没指向同一个方法，内存浪费
console.log(tom.say == jarry.say);
console.log(tom.say == Cat.prototype.say);
                </pre>
                <button onclick="fun1()">演示</button>
            </div>
            <div>
                <h3>原型链继承</h3>
                <pre>
function Mouse(name) {
    this.name = name;
}

//构造函数中的原型方法最好在创建完原型后立即创建
//js为动态语言，在后期更改原型链中方法会对原有的更改
Mouse.prototype.say = function () {
    console.log(this.name + "是老鼠");
};

var tom = new Mouse("TOM");
var jarry = new Mouse("Jarry");

tom.say();
jarry.say();
console.log(tom);
console.log(jarry);

console.log(tom.say == jarry.say); //指向同一个方法，这种方法避免了内存的浪费
console.log(tom.say == Mouse.prototype.say);
                </pre>
                <button onclick="fun2()">演示</button>
            </div>
        </section>
        <script>
            function isChild(child, father) {
                return child instanceof father;
            }

            function fun1() {
                function Cat(name) {
                    this.name = name;
                    this.say = function () {
                        console.log(this.name + "是猫");
                    };
                }

                var tom = new Cat("TOM");
                var jarry = new Cat("JARRY");

                tom.say();
                jarry.say();

                console.log(tom);
                console.log(jarry);
                console.log(isChild(tom, Cat));

                //没指向同一个方法，内存浪费
                console.log(tom.say == jarry.say);
                console.log(tom.say == Cat.prototype.say);
            }

            function fun2() {
                function Mouse(name) {
                    this.name = name;
                }

                //构造函数中的原型方法最好在创建完原型后立即创建
                //js为动态语言，在后期更改原型链中方法会对原有的更改
                Mouse.prototype.say = function () {
                    console.log(this.name + "是老鼠");
                };

                var tom = new Mouse("TOM");
                var jarry = new Mouse("Jarry");

                tom.say();
                jarry.say();
                console.log(tom);
                console.log(jarry);
                console.log(isChild(tom, Mouse));

                //指向同一个方法，这种方法避免了内存的浪费
                console.log(tom.say == jarry.say);
                console.log(tom.say == Mouse.prototype.say);
            }
        </script>
    </body>
</html>
